"""Data models for serendipity recommendations."""

from dataclasses import dataclass, field
from typing import Optional


@dataclass
class Recommendation:
    """A single recommendation with optional rich metadata.

    Supports both simple (url, reason) format for backwards compatibility
    and extended format with type-specific metadata.
    """
    url: str
    reason: str

    # Recommendation categorization
    approach: str = "convergent"  # convergent, divergent, etc.
    media_type: str = "article"   # youtube, book, article, podcast, etc.

    # Common optional fields
    title: Optional[str] = None
    thumbnail_url: Optional[str] = None

    # Type-specific metadata stored as dict
    # Examples:
    #   youtube: {channel, duration, views}
    #   book: {author, year, publisher}
    #   article: {publication, read_time, excerpt}
    metadata: dict = field(default_factory=dict)

    def to_dict(self) -> dict:
        """Convert to dictionary for JSON serialization."""
        result = {
            "url": self.url,
            "reason": self.reason,
            "approach": self.approach,
            "media_type": self.media_type,
        }
        if self.title:
            result["title"] = self.title
        if self.thumbnail_url:
            result["thumbnail_url"] = self.thumbnail_url
        if self.metadata:
            result["metadata"] = self.metadata
        return result

    @classmethod
    def from_dict(cls, data: dict, approach: str = "convergent") -> "Recommendation":
        """Create from dictionary, handling both simple and extended formats."""
        # Handle "description" as fallback for "reason"
        reason = data.get("reason") or data.get("description", "")
        return cls(
            url=data.get("url", ""),
            reason=reason,
            approach=data.get("approach", approach),
            media_type=data.get("type", data.get("media_type", "article")),
            title=data.get("title"),
            thumbnail_url=data.get("thumbnail_url"),
            metadata=data.get("metadata", {}),
        )


@dataclass
class Pairing:
    """A single pairing item (contextual bonus content).

    Pairings are complementary suggestions like music, food, exercises,
    or tips that enhance the mood of discoveries.
    """
    type: str  # music, exercise, food, tip, etc.
    content: str  # The pairing suggestion/description
    url: Optional[str] = None  # Optional link for search-based pairings
    title: Optional[str] = None  # Optional title
    metadata: dict = field(default_factory=dict)

    def to_dict(self) -> dict:
        """Convert to dictionary for JSON serialization."""
        result = {
            "type": self.type,
            "content": self.content,
        }
        if self.url:
            result["url"] = self.url
        if self.title:
            result["title"] = self.title
        if self.metadata:
            result["metadata"] = self.metadata
        return result

    @classmethod
    def from_dict(cls, data: dict) -> "Pairing":
        """Create from dictionary."""
        return cls(
            type=data.get("type", "tip"),
            content=data.get("content", ""),
            url=data.get("url"),
            title=data.get("title"),
            metadata=data.get("metadata", {}),
        )


@dataclass
class HtmlStyle:
    """HTML styling generated by Claude."""
    description: str
    css: str


@dataclass
class StatusEvent:
    """A status event for SSE streaming during get_more.

    Event types:
    - status: General status message
    - tool_use: Tool being called (WebSearch, etc.)
    - tool_result: Tool result received
    - thinking: Thinking block (if verbose)
    - complete: Final result with recommendations
    - error: Error occurred
    """
    event: str  # status, tool_use, tool_result, thinking, complete, error
    data: dict = field(default_factory=dict)

    def to_sse(self) -> str:
        """Convert to SSE format string."""
        import json
        return f"event: {self.event}\ndata: {json.dumps(self.data)}\n\n"
