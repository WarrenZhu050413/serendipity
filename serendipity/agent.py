"""Claude Agent for serendipity discovery."""

import asyncio
import json
import re
from dataclasses import dataclass, field
from pathlib import Path
from typing import Optional

from claude_agent_sdk import (
    AssistantMessage,
    ClaudeAgentOptions,
    ClaudeSDKClient,
    ResultMessage,
    TextBlock,
    ThinkingBlock,
    ToolResultBlock,
    ToolUseBlock,
)
from rich.console import Console

from serendipity.display import AgentDisplay, DisplayConfig

PROMPT_TEMPLATE = Path(__file__).parent / "prompt.txt"


@dataclass
class Recommendation:
    """A single recommendation."""

    url: str
    reason: str


@dataclass
class HtmlStyle:
    """HTML styling generated by Claude."""

    description: str
    css: str


@dataclass
class DiscoveryResult:
    """Result from a discovery operation."""

    convergent: list[Recommendation]
    divergent: list[Recommendation]
    session_id: str
    cost_usd: Optional[float] = None
    raw_response: Optional[str] = None
    html_style: Optional[HtmlStyle] = None


class SerendipityAgent:
    """Claude agent for serendipity discovery."""

    def __init__(
        self,
        console: Optional[Console] = None,
        model: str = "opus",
        verbose: bool = False,
    ):
        """Initialize the Serendipity agent.

        Args:
            console: Rich console for output
            model: Claude model to use (haiku, sonnet, opus)
            verbose: Show detailed progress
        """
        self.console = console or Console()
        self.model = model
        self.verbose = verbose
        self.prompt_template = PROMPT_TEMPLATE.read_text()
        self.last_session_id: Optional[str] = None
        self.cost_usd: Optional[float] = None

    async def discover(
        self,
        context: str,
        n1: int = 5,
        n2: int = 5,
        context_augmentation: str = "",
        style_guidance: str = "",
    ) -> DiscoveryResult:
        """Run discovery on user context.

        Args:
            context: User's context (text, links, instructions)
            n1: Number of convergent recommendations
            n2: Number of divergent recommendations
            context_augmentation: Additional context (preferences, history)
            style_guidance: Style guidance for HTML output

        Returns:
            DiscoveryResult with recommendations
        """
        # Build full context
        full_context_parts = []
        if context_augmentation:
            full_context_parts.append(context_augmentation)
        full_context_parts.append(f"<current_context>\n{context}\n</current_context>")
        if style_guidance:
            full_context_parts.append(style_guidance)

        full_context = "\n\n".join(full_context_parts)

        prompt = self.prompt_template.format(
            user_context=full_context,
            n1=n1,
            n2=n2,
        )

        options = ClaudeAgentOptions(
            model=self.model,
            system_prompt="You are a discovery engine.",
            max_turns=20,  # Enough for multiple searches
            allowed_tools=["WebFetch", "WebSearch"],
        )

        response_text = []
        session_id = ""
        cost_usd = None

        # Set up display for streaming output
        display = AgentDisplay(
            console=self.console,
            config=DisplayConfig(verbose=self.verbose),
        )

        async with ClaudeSDKClient(options=options) as client:
            await client.query(prompt)

            async for msg in client.receive_response():
                if isinstance(msg, AssistantMessage):
                    for block in msg.content:
                        if isinstance(block, ThinkingBlock):
                            display.show_thinking(block.thinking)

                        elif isinstance(block, ToolUseBlock):
                            display.show_tool_use(
                                name=block.name,
                                tool_id=block.id,
                                input_data=block.input or {},
                            )

                        elif isinstance(block, ToolResultBlock):
                            display.show_tool_result(
                                tool_use_id=block.tool_use_id,
                                content=block.content,
                                is_error=block.is_error,
                            )

                        elif isinstance(block, TextBlock):
                            response_text.append(block.text)
                            display.show_text(block.text)

                elif isinstance(msg, ResultMessage):
                    session_id = msg.session_id
                    cost_usd = msg.total_cost_usd

        self.last_session_id = session_id
        self.cost_usd = cost_usd

        # Parse JSON from response
        full_response = "".join(response_text)
        parsed = self._parse_json(full_response)

        # Extract html_style if present
        html_style = None
        if "html_style" in parsed:
            style_data = parsed["html_style"]
            if isinstance(style_data, dict):
                html_style = HtmlStyle(
                    description=style_data.get("description", ""),
                    css=style_data.get("css", ""),
                )

        return DiscoveryResult(
            convergent=[
                Recommendation(url=r.get("url", ""), reason=r.get("reason", ""))
                for r in parsed.get("convergent", [])
            ],
            divergent=[
                Recommendation(url=r.get("url", ""), reason=r.get("reason", ""))
                for r in parsed.get("divergent", [])
            ],
            session_id=session_id,
            cost_usd=cost_usd,
            raw_response=full_response,
            html_style=html_style,
        )

    async def get_more(
        self,
        session_id: str,
        rec_type: str,
        count: int = 5,
    ) -> list[Recommendation]:
        """Get more recommendations by resuming a session.

        Args:
            session_id: Session ID to resume
            rec_type: Type of recommendations ("convergent" or "divergent")
            count: Number of additional recommendations

        Returns:
            List of new recommendations
        """
        type_description = (
            "convergent (matching their taste directly)"
            if rec_type == "convergent"
            else "divergent (expanding their palette)"
        )

        prompt = f"""Give me {count} more {type_description} recommendations, different from what you've already suggested.

Output as JSON:
{{
  "{rec_type}": [{{"url": "...", "reason": "..."}}]
}}"""

        options = ClaudeAgentOptions(
            model=self.model,
            system_prompt="You are a discovery engine.",
            max_turns=10,
            allowed_tools=["WebFetch", "WebSearch"],
            resume=session_id,  # Resume the previous session
        )

        response_text = []
        new_session_id = ""
        cost_usd = None

        # Set up display for streaming output
        display = AgentDisplay(
            console=self.console,
            config=DisplayConfig(verbose=self.verbose),
        )

        async with ClaudeSDKClient(options=options) as client:
            await client.query(prompt)

            async for msg in client.receive_response():
                if isinstance(msg, AssistantMessage):
                    for block in msg.content:
                        if isinstance(block, ThinkingBlock):
                            display.show_thinking(block.thinking)

                        elif isinstance(block, ToolUseBlock):
                            display.show_tool_use(
                                name=block.name,
                                tool_id=block.id,
                                input_data=block.input or {},
                            )

                        elif isinstance(block, ToolResultBlock):
                            display.show_tool_result(
                                tool_use_id=block.tool_use_id,
                                content=block.content,
                                is_error=block.is_error,
                            )

                        elif isinstance(block, TextBlock):
                            response_text.append(block.text)
                            display.show_text(block.text)

                elif isinstance(msg, ResultMessage):
                    new_session_id = msg.session_id
                    cost_usd = msg.total_cost_usd

        # Update session and cost
        self.last_session_id = new_session_id
        if cost_usd:
            self.cost_usd = (self.cost_usd or 0) + cost_usd

        # Parse JSON from response
        full_response = "".join(response_text)
        parsed = self._parse_json(full_response)

        return [
            Recommendation(url=r.get("url", ""), reason=r.get("reason", ""))
            for r in parsed.get(rec_type, [])
        ]

    def _parse_json(self, text: str) -> dict:
        """Extract JSON from response text."""
        # Try to find <output> tags first
        output_match = re.search(r"<output>\s*(.*?)\s*</output>", text, re.DOTALL)
        if output_match:
            try:
                return json.loads(output_match.group(1))
            except json.JSONDecodeError:
                pass

        # Try to find JSON block (may be wrapped in markdown code block)
        json_match = re.search(r"```json?\s*(.*?)\s*```", text, re.DOTALL)
        if json_match:
            try:
                return json.loads(json_match.group(1))
            except json.JSONDecodeError:
                pass

        # Try to find raw JSON object
        json_match = re.search(r"\{[\s\S]*\}", text)
        if json_match:
            try:
                return json.loads(json_match.group(0))
            except json.JSONDecodeError:
                pass

        # Fallback: return empty structure
        self.console.print("[yellow]Warning: Could not parse JSON from response[/yellow]")
        return {"convergent": [], "divergent": []}

    def run_sync(
        self,
        context: str,
        n1: int = 5,
        n2: int = 5,
        context_augmentation: str = "",
        style_guidance: str = "",
    ) -> DiscoveryResult:
        """Sync wrapper for discover.

        Args:
            context: User's context
            n1: Number of convergent recommendations
            n2: Number of divergent recommendations
            context_augmentation: Additional context (preferences, history)
            style_guidance: Style guidance for HTML output

        Returns:
            DiscoveryResult
        """
        return asyncio.run(
            self.discover(
                context,
                n1,
                n2,
                context_augmentation=context_augmentation,
                style_guidance=style_guidance,
            )
        )

    def get_more_sync(
        self,
        session_id: str,
        rec_type: str,
        count: int = 5,
    ) -> list[Recommendation]:
        """Sync wrapper for get_more.

        Args:
            session_id: Session ID to resume
            rec_type: Type of recommendations
            count: Number of additional recommendations

        Returns:
            List of new recommendations
        """
        return asyncio.run(self.get_more(session_id, rec_type, count))

    def get_resume_command(self) -> Optional[str]:
        """Get the command to resume the last session.

        Returns:
            Command string to resume session, or None if no session
        """
        if self.last_session_id:
            return f"claude -r {self.last_session_id}"
        return None
